<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Templet Tool</title>
    <script src="gat-0.4.js"> </script>
    <script src="svg.min.js"> </script>
    <script src="osm-read-pbf.js"> </script>
    <script src="svg-pan-zoom.js"> </script>
    <link rel="stylesheet" type="text/css" href="tool-gui.css">
</head>
<body>
<script>

let map;
let startText;
let drawRulesInputJson;
const mapAreaWidthDegreeAddition = 0.004;



if(gat.getURLQueryParam("f") !== null){
  startText = gat.getURLQueryParam("f");
} else {
  startText = 
`[{
 "canvas size": [1000,1000],
 "zoom": 1.0,
 "pan": [0,0]
},
{
 "fill color": "#00af00",
 "line width": 6,
 "type": "way",
 "tags": [
   ["landuse", "forest"]
  ]
},
{
 "stroke color": "#707070",
 "line width": 2,
 "type": "way",
 "tags": [
  ["highway","*"]
 ]
},
{
 "stroke color": "#a0a0a0",
 "line width": 2,
 "type": "way",
 "tags": [
   ["building","*"]
 ]
},
{
 "stroke color": "#0000ff",
 "line width": 4,
 "type": "way",
 "tags": [
  ["natural", "coastline"]
 ]
},
{
 "stroke color": "#ff0000",
 "line width": 5,
 "type": "node",
 "size": 4,
 "tags": [
  ["highway", "crossing"]
 ]
}]
`
}

const uiObj = setUpGui();

const svgDiv = new gat.CenteredElement("div", [1000,1000], {borderAlpha:0.96});
svgDiv.element.style.backgroundColor="#ffffff";
uiObj.canvasDiv.appendChild(svgDiv.element);
svgDiv.resize();

window.addEventListener("resize", draw);

window.addEventListener("keyup", (event) => {
    if (document.activeElement.tagName == "TEXTAREA" || document.activeElement.tagName == "INPUT") return
    if(event.key === "s"){
      gat.downloadText("map" + ".svg", draw(true));
    }
  });

drawRulesInputJson = JSON.parse(uiObj.textarea.value);
updateMapObj(draw);

function setUpGui(){
  let uiObj = new gat.ui();

  uiObj.addButton("new map", newOsmMap);
  uiObj.addButton("show tags", showAvailableTags);

  let textarea = uiObj.addTextarea("map settings", startText, function(){});
  textarea.rows = 40;
  textarea.style.fontSize = "medium";
  textarea.style.width="94%";
  uiObj.addFinishedTypingCallback(mapSettingsChanged, 600);

  uiObj.addButton("save map", function(){
    gat.downloadText("map" + ".svg", draw(true));
  })

  uiObj.textarea = textarea;

  return uiObj;

  function showAvailableTags(){
    alert("Way Tags:" + getTagOverviewString(map.tagOverviewWay) + "\n\n\nNode Tags:" + getTagOverviewString(map.tagOverviewNode))
  }

  function getTagOverviewString(tagOverview){
      let stringOut = "";
      for(let tag1 of Object.entries(tagOverview)){
        stringOut += "\n" + tag1[0];
        let tag2Array = Object.entries(tag1[1]);
        tag2Array.sort(function(a, b){
          if(a[1] === b[1]) return 0;
          else return (a[1] > b[1]) ? -1 : 1;
        })
        for(let tag2 of tag2Array){
          stringOut += "\n  " + tag2[0] + ": " + tag2[1];
        }
      }
    return stringOut;
    }
}


function newOsmMap(){
  let osmURL = prompt("Enter the openstreetmap URL of the map you want to generate and then select the fitting .osm.pbf file you can download here: http://download.geofabrik.de", "");

  const fileInput = document.createElement("input");
  fileInput.type = "file";
  fileInput.accept = ".pbf"
  
  fileInput.addEventListener("change", function(){
    let reader = new FileReader();
    reader.onload = function() {
      drawRulesInputJson = JSON.parse(textarea.value);
      
      updateMapObj(draw, this.result, osmURL)
    }
    reader.readAsArrayBuffer(this.files[0]);
  }, false);
  
  fileInput.click();
}


function mapSettingsChanged(){
  drawRulesInputJson = JSON.parse(uiObj.textarea.value);
  draw();
}


function draw(saveFlag){
  if(saveFlag !== true){
    gat.setURLQueryParam("f", uiObj.textarea.value)
    
    let mainSVG = document.getElementById("mainSVG");
    if(mainSVG !== null) mainSVG.remove();
  }
  
  let size = drawRulesInputJson[0]["canvas size"];
  svgDiv.size = size

  var ctx = SVG();
  ctx.viewbox(0, 0, ...size)

  ctx.node.id = "mainSVG";
  ctx.node.style="width:100%; height:100%"
  ctx.stroke({linecap: 'round', linejoin: 'round'})

  

  if(saveFlag === true){
    let rect = ctx.rect(9*size[0], 9*size[1]);
    rect.move(-4*size[0], -4*size[1])
    rect.fill("#ffffff")
    let scale = drawRulesInputJson[0]["zoom"];
    let panX = drawRulesInputJson[0]["pan"][0];
    let panY = drawRulesInputJson[0]["pan"][1]
    ctx.transform({
      a: scale, b: 0, c: 0, d: scale, e: panX, f: panY
    })
  }

  

  let drawingSettings = getDrawingSettings(drawRulesInputJson);

  for(tag of drawingSettings.drawingOrder){
    if(tag[2] === "way"){
      if(drawingSettings.orderedWays[tag[0]] === undefined || drawingSettings.orderedWays[tag[0]][tag[1]] === undefined) continue;
      drawWays(ctx, drawingSettings, tag);
    } else if(tag[2] === "node"){
      if(drawingSettings.orderedNodes[tag[0]] === undefined || drawingSettings.orderedNodes[tag[0]][tag[1]] === undefined) continue;
      drawNodes(ctx, drawingSettings, tag);
    }
  }

  if(saveFlag === true){
    return ctx.svg()
  } else {
    ctx.addTo(svgDiv.element);
    var panZoomSVG = svgPanZoom("#mainSVG", {
      controlIconsEnabled: true,
      onZoom: function(){
        let zoom = Math.round(panZoomSVG.getZoom()*10000)/10000
        drawRulesInputJson[0]["zoom"] = zoom;
        uiObj.textarea.value = uiObj.textarea.value.replace(new RegExp(/"zoom": [+-]?\d+(\.\d+)?/), "\"zoom\": " + zoom)
        gat.setURLQueryParam("f", uiObj.textarea.value)
      },
      onPan: function(){
        let pan = panZoomSVG.getPan()
        // map to "canvas size" to get pan right no matter the actual client Size
        pan.x = pan.x / svgDiv.element.clientWidth * drawRulesInputJson[0]["canvas size"][0];
        pan.y = pan.y / svgDiv.element.clientHeight * drawRulesInputJson[0]["canvas size"][1];
        
        pan.x = Math.round(pan.x*10000)/10000;
        pan.y = Math.round(pan.y*10000)/10000;

        drawRulesInputJson[0]["pan"] = [pan.x, pan.y]
        uiObj.textarea.value = uiObj.textarea.value.replace(new RegExp(/"pan": \[[+-]?\d+(\.\d+)?\,[+-]?\d+(\.\d+)?\]/), "\"pan\": [" + pan.x  + "," + pan.y + "]")
        gat.setURLQueryParam("f", uiObj.textarea.value)
      },
    })

    // map to client size to get pan right no matter the actual client Size
    let panX = drawRulesInputJson[0]["pan"][0] / drawRulesInputJson[0]["canvas size"][0] * svgDiv.element.clientWidth;
    let panY = drawRulesInputJson[0]["pan"][1] / drawRulesInputJson[0]["canvas size"][1] * svgDiv.element.clientHeight;

    panZoomSVG.zoom(drawRulesInputJson[0]["zoom"]);
    panZoomSVG.pan({x:panX, y:panY});

    return;
  }

  function drawNodes(ctx, drawingSettings, tag){
    tagDrawSettings = drawingSettings.drawRulesNodes[tag[0]][tag[1]];
    for(xy of drawingSettings.orderedNodes[tag[0]][tag[1]]){
      let circle = ctx.circle(tagDrawSettings.size);
      circle.move(xy[0], xy[1]);
      circle.fill(tagDrawSettings.fillColor);
      if(tagDrawSettings.strokeColor !== undefined){
        circle.stroke({widht: tagDrawSettings.lineWidth, color: tagDrawSettings.strokeColor})
      }
    }
  }

  function drawWays(ctx, drawingSettings, tag){
    tagDrawSettings = drawingSettings.drawRulesWays[tag[0]][tag[1]];
    for(nodeRefs of drawingSettings.orderedWays[tag[0]][tag[1]]){
      let beginPath = true;
      let polylinePoints = [];
      for(nodeId of nodeRefs){
        if(map.nodes[nodeId] == undefined){
          beginPath = true;
          continue;
        } else if(beginPath == true){
          drawPolyline(polylinePoints, tagDrawSettings)
          beginPath = false;
        }
        polylinePoints.push(map.nodes[nodeId].x);
        polylinePoints.push(map.nodes[nodeId].y);
      }
      drawPolyline(polylinePoints, tagDrawSettings)
    }
  }

  function drawPolyline(polylinePoints, tagDrawSettings){
    if(polylinePoints.length>0){
      let polyline = ctx.polyline(polylinePoints);
      polyline.fill(tagDrawSettings.fillColor);
      polyline.stroke({width: tagDrawSettings.lineWidth, color: tagDrawSettings.strokeColor})
      polylinePoints = []
    }
  }
}


async function updateMapObj(callback, mapArrayBuffer, osmURL){
  let filePath;
  if(mapArrayBuffer === undefined) {
    filePath = "monaco-latest.osm.pbf";
    osmURL = "https://www.openstreetmap.org/#map=17/43.72957/7.42408";
  }

  loaderText = gat.addLoaderText();
  
  map = getEmptyMapWithBorders(osmURL);

  loaderText.innerText = "loading ...";

  await pbfParser.parse(getpbfParser(callback, filePath, mapArrayBuffer));

  function getEmptyMapWithBorders(osmURL){
    let zoomlevel, midLat, midLon;
    let valueBeginIndex = osmURL.search("#map") + 5;
    [zoomlevel, midLat, midLon] = osmURL.substr(valueBeginIndex).split("/").map(value => parseFloat(value));

    let widthLon = 360 / Math.pow(2, zoomlevel);
    let widthHeightRatio = svgDiv.element.height/svgDiv.element.width;
    let heightLat = widthLon*widthHeightRatio;

    let map = {
      nodes: {},
      ways: {},
      relations: {},
      counterNode: 0,
      counterWay: 0,

      tagOverviewWay:{},
      tagOverviewNode:{},
      

      mapPixelWidth: svgDiv.element.width,
      mapPixelHeight: svgDiv.element.height,
      mapLonDelta: widthLon,
      mapLonLeft: midLon - widthLon/2,
      mapLatBottomDegree: midLat,

      minLon: midLon - widthLon/2 - mapAreaWidthDegreeAddition,
      minLat: midLat - heightLat/2 - mapAreaWidthDegreeAddition,
      maxLon: midLon + widthLon/2 + mapAreaWidthDegreeAddition,
      maxLat: midLat + heightLat/2 + mapAreaWidthDegreeAddition,

      canvasWidth: svgDiv.element.width,
      canvasHeight: svgDiv.element.height,
    }

    let borderXY = [
      ...convertGeoToGlobalPixel(map, midLat - heightLat/2, midLon - widthLon/2),
      ...convertGeoToGlobalPixel(map, midLat + heightLat/2, midLon + widthLon/2)
    ];

    map.borderXY = borderXY;
    map.width = borderXY[2] - borderXY[0];
    map.height = borderXY[3] - borderXY[1];

    return map;
  }

  function getpbfParser(callback, filePath, mapArrayBuffer){
    return {
      filePath: filePath,
      buffer: mapArrayBuffer,
      interval: setInterval(function(){
        loaderText.innerText = "loaded: " + map.counterNode + " ways and " + map.counterWay + " nodes";
      }, 1000),
      startTime: Date.now(), 
      endDocument: function(){
        
        clearInterval(this.interval)
        let millis = Date.now() - this.startTime;
        console.log(millis/1000, "seconds to load the selected area");
        
        gat.removeLoaderText();
        callback();
      },
      node: function(node){
        if(node.lon<map.minLon || node.lat<map.minLat || node.lon>map.maxLon || node.lat>map.maxLat) return

        [x, y] = convertGeoToCanvasPixel(map, node.lat, node.lon);
        map.nodes[node.id] = {
          x: x,
          y: y,
          tags: Object.entries(node.tags),
        }
        countTag(map.tagOverviewNode, node.tags);
        map.counterNode++;
      },
      way: function(way){
        for(nodeKey of way.nodeRefs){
          if(map.nodes[nodeKey]){
            map.ways[way.id] = {
              nodeRefs: way.nodeRefs,
              tags: Object.entries(way.tags),
            }
            countTag(map.tagOverviewWay, way.tags);
            map.counterWay++;
            return;
          }
        }
      },
      relation: function(relation){},
      error: function(msg){
        console.error('error: ' + msg);
        throw msg;
      }
    }
  }

  function convertGeoToCanvasPixel(map, lat, lon){
    [x, y] = convertGeoToGlobalPixel(map, lat, lon);
    x = (x-map.borderXY[0])/map.width * map.canvasWidth;
    y = (y-map.borderXY[1])/map.height * map.canvasHeight;
    y = -(y - map.canvasHeight/2) + map.canvasHeight/2;
    return [x, y]
  }

  function convertGeoToGlobalPixel(map, lat, lon){
    let x = (lon - map.mapLonLeft) * (map.mapPixelWidth / map.mapLonDelta);
    lat = lat * Math.PI / 180;
    let worldMapWidth = ((map.mapPixelWidth / map.mapLonDelta) * 360) / (2 * Math.PI);
    let mapOffsetY = (worldMapWidth / 2 * Math.log((1 + Math.sin(map.mapLatBottomDegree)) / (1 - Math.sin(map.mapLatBottomDegree))));
    let y = map.mapPixelHeight - ((worldMapWidth / 2 * Math.log((1 + Math.sin(lat)) / (1 - Math.sin(lat)))) - mapOffsetY);
    return [x, y];
  }

  function countTag(saveInObj, tagObj){
    const tagsThatAreCounted = {
      amenity:true, boundary:true, building:true, highway: true, landuse:true, natural:true, place:true, railway:true, waterway:true,
    }
    let tagArray = Object.entries(tagObj)
    for(let tag of tagArray){
      if(tagsThatAreCounted[tag[0]]){
        if(saveInObj[tag[0]]===undefined){
          saveInObj[tag[0]] = {};
      }
      if(saveInObj[tag[0]][tag[1]]===undefined){
        saveInObj[tag[0]][tag[1]] = 1;
      } else {
        saveInObj[tag[0]][tag[1]]++;
      }
      }
    }
  }
}


function getDrawingSettings(drawRulesInputJson){
  let drawingSettings = getDrawingSettingsRulesAndOrder(drawRulesInputJson);

  drawingSettings.orderedWays = getOrderedWays(drawingSettings);
  drawingSettings.orderedNodes = getOrderedNodes(drawingSettings);
  return drawingSettings;

  function getDrawingSettingsRulesAndOrder(drawRulesInputJson){
    let drawingSettings = {};
    drawingSettings.drawRulesWays = {};
    drawingSettings.drawRulesNodes = {};
    drawingSettings.drawingOrder = [];

    for(let drawRule of drawRulesInputJson){
      drawSettings = {
        strokeColor: drawRule["stroke color"],
        lineWidth: drawRule["line width"],
        fillColor: drawRule["fill color"],
        size: drawRule["size"],
      }
      if(drawSettings.fillColor === undefined) drawSettings.fillColor = "none";
      if(drawRule.type === "way"){
        for(let tag of drawRule.tags){
          if(drawingSettings.drawRulesWays[tag[0]] === undefined){
            drawingSettings.drawRulesWays[tag[0]] = {};
          }
          drawingSettings.drawRulesWays[tag[0]][tag[1]] = drawSettings;
          drawingSettings.drawingOrder.push([tag[0], tag[1], "way"])
        } 
      } else if(drawRule.type === "node"){
        for(let tag of drawRule.tags){
          if(drawingSettings.drawRulesNodes[tag[0]] === undefined){
            drawingSettings.drawRulesNodes[tag[0]] = {};
          }
          drawingSettings.drawRulesNodes[tag[0]][tag[1]] = drawSettings;
          drawingSettings.drawingOrder.push([tag[0], tag[1], "node"])
        } 
      }
    }
    return drawingSettings;
  }

  function getOrderedWays(drawingSettings){
    let orderedWays = {}
    for(let way of Object.entries(map.ways)){
      for(let tag of way[1].tags){
        let rule = drawingSettings.drawRulesWays[tag[0]];
        if(rule !== undefined){
          if(rule["*"] !== undefined){
            if(orderedWays[tag[0]] === undefined){
              orderedWays[tag[0]] = {};
            }
            if(orderedWays[tag[0]]["*"] === undefined){
              orderedWays[tag[0]]["*"] = [];
            }
            orderedWays[tag[0]]["*"].push(way[1].nodeRefs);
          } else if(rule[tag[1]] !== undefined){
            if(orderedWays[tag[0]] === undefined){
              orderedWays[tag[0]] = {};
            }
            if(orderedWays[tag[0]][tag[1]] === undefined){
              orderedWays[tag[0]][tag[1]] = [];
            }
            orderedWays[tag[0]][tag[1]].push(way[1].nodeRefs);
          }
        }
      }
    }
    return orderedWays;
  }

  function getOrderedNodes(drawingSettings){
    let orderedNodes = {};
    for(let node of Object.entries(map.nodes)){
      for(let tag of node[1].tags){
        let rule = drawingSettings.drawRulesNodes[tag[0]];
        if(rule !== undefined){
          if(rule["*"] !== undefined){
            if(orderedNodes[tag[0]] === undefined){
              orderedNodes[tag[0]] = {};
            }
            if(orderedNodes[tag[0]]["*"] === undefined){
              orderedNodes[tag[0]]["*"] = [];
            }
            orderedNodes[tag[0]]["*"].push([node[1].x, node[1].y]);
          } else if(rule[tag[1]] !== undefined){
            if(orderedNodes[tag[0]] === undefined){
              orderedNodes[tag[0]] = {};
            }
            if(orderedNodes[tag[0]][tag[1]] === undefined){
              orderedNodes[tag[0]][tag[1]] = [];
            }
            orderedNodes[tag[0]][tag[1]].push([node[1].x, node[1].y]);
          }
        }
      }
    }
    return orderedNodes;
  }
}



</script>