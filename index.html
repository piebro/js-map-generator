<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Templet Tool</title>
    <script src="gat-0.4.js"> </script>
    <script src="svg.min.js"> </script>
    <script src="osm-read-pbf.js"> </script>
    <script src="svg-pan-zoom.js"> </script>
    <link rel="stylesheet" type="text/css" href="tool-gui.css">
</head>
<body>
<script>

let map;
let startText;
let drawRulesInputJson;
let currentFileName;
let currentOsmUrl;
let drawFirstMapFromUrlWithFileInput = false;

const mapAreaWidthDegreeAddition = 0.004;
const localFileNames = [
  "monaco-latest.osm.pbf",
  // https://www.openstreetmap.org/#map=18/43.73374/7.41638
  "isle-of-man-latest.osm.pbf",
  // https://www.openstreetmap.org/#map=18/54.15007/-4.48207
  "liechtenstein-latest.osm.pbf",
  // https://www.openstreetmap.org/relation/1155955#map=17/47.14617/9.51859
  "seychelles-latest.osm.pbf",
  // https://www.openstreetmap.org/relation/536765#map=17/-4.62276/55.45097
]


if(gat.getURLQueryParam("settings") !== null && gat.getURLQueryParam("file-name") !== null && gat.getURLQueryParam("osm-url") !== null){
  
  startText = gat.getURLQueryParam("settings");
  startText = startText.replace(/%23/g, "#")

  currentFileName = gat.getURLQueryParam("file-name");
  currentOsmUrl = gat.getURLQueryParam("osm-url");

  // check if file-name is locally available
  if(localFileNames.indexOf(currentFileName) === -1){
    drawFirstMapFromUrlWithFileInput = true;
    
  }
}
else {
  currentFileName = "monaco-latest.osm.pbf";
  currentOsmUrl = "https://www.openstreetmap.org/#map=18/43.73374/7.41638";
  startText = 
`[{
 "canvas size": [1000,1000],
 "zoom": 2.2108,
 "pan": [361.4961,-1003.5468],
 "background": "#005000"
},
{
 "stroke color": "#707070",
 "line width": 2,
 "type": "way",
 "tags": [
  ["highway","primary"],
  ["highway","residential"],
  ["highway","path"]
 ]
},
{
 "stroke color": "#a0a0a0",
 "fill color": "#a0a0a0",
 "line width": 2,
 "type": "way",
 "tags": [
   ["building","*"]
 ]
},
{
 "fill color": "#008000",
 "type": "node",
 "size": 20,
 "tags": [
  ["natural", "tree"]
 ]
},
{
 "stroke color": "#ff0000",
 "line width": 5,
 "type": "way",
 "tags": [
  ["railway", "*"]
 ]
},
{
 "stroke color": "#2020a0",
 "fill color": "#2020a0",
 "line width": 2,
 "type": "way",
 "tags": [
   ["place","*"]
 ]
}]`
}


const uiObj = setUpGui();

const svgDiv = new gat.CenteredElement("div", [1000,1000], {borderAlpha:0.96});
svgDiv.element.style.backgroundColor="#ffffff";
uiObj.canvasDiv.appendChild(svgDiv.element);
svgDiv.resize();

window.addEventListener("resize", draw);

window.addEventListener("keyup", (event) => {
  if (document.activeElement.tagName == "TEXTAREA" || document.activeElement.tagName == "INPUT") return
  if(event.key === "s"){
    gat.downloadText("map" + ".svg", draw(true));
  }
});

if(drawFirstMapFromUrlWithFileInput === false){
  drawRulesInputJson = JSON.parse(uiObj.textarea.value);
  updateMapObj(draw);
}
else {
  uploadButton = gat.addLoaderText();
  uploadButton.innerText = "The file: \"" + currentFileName + "\" is needed for the map. You can go to https://download.geofabrik.de, download it and then click here to use it."
  uploadButton.onclick = function(){
    triggerFileInput();
    gat.removeLoaderText();
  }
}



function setUpGui(){
  let uiObj = new gat.ui();

  uiObj.addButton("new map", newOsmMap);
  uiObj.addButton("show tags", showAvailableTags);

  let textarea = uiObj.addTextarea("map settings", startText, function(){});
  textarea.rows = 40;
  textarea.style.fontSize = "medium";
  textarea.style.width="94%";
  textarea.autofocus = true;
  uiObj.addFinishedTypingCallback(mapSettingsChanged, 600);

  uiObj.addButton("save map", function(){
    gat.downloadText("map" + ".svg", draw(true));
  })

  uiObj.textarea = textarea;

  return uiObj;

  function showAvailableTags(){
    [nodeTags, wayTags] = getCurrentVisibleTags();
    alert("Way Tags:" + getTagOverviewString(wayTags) + "\n\n\nNode Tags:" + getTagOverviewString(nodeTags))
  }

  function getCurrentVisibleTags(){
    let size = drawRulesInputJson[0]["canvas size"];
    let zoom = drawRulesInputJson[0]["zoom"];
    let pan = drawRulesInputJson[0]["pan"];
    
    let border = [
      - pan[0],
      - pan[1],
      Math.round(size[0]/zoom - pan[0]),
      Math.round(size[1]/zoom - pan[1]),
    ]

    let nodeTags = {}
    for(let node of Object.entries(map.nodes)){
      if(node[1].x>=border[0] && node[1].y>=border[1] && node[1].x<=border[2] && node[1].y<=border[3]){
        countTag(nodeTags, node[1].tags)
      }
    }

    let wayTags = {}
    for(let way of Object.entries(map.ways)){
      for(let nodeId of way[1].nodeRefs){
        let node = map.nodes[nodeId];
        if(node !== undefined && node.x>=border[0] && node.y>=border[1] && node.x<=border[2] && node.y<=border[3]){
          countTag(wayTags, way[1].tags)
          continue;
        }
      }
    }
    return [nodeTags, wayTags];
  }

  function countTag(saveInObj, tagArray){
    const tagsThatAreCounted = {
      amenity:true, boundary:true, building:true, highway: true, landuse:true, natural:true, place:true, railway:true, waterway:true,
    }
    //let tagArray = Object.entries(tagObj)
    for(let tag of tagArray){
      if(tagsThatAreCounted[tag[0]]){
        if(saveInObj[tag[0]]===undefined){
          saveInObj[tag[0]] = {};
      }
      if(saveInObj[tag[0]][tag[1]]===undefined){
        saveInObj[tag[0]][tag[1]] = 1;
      } else {
        saveInObj[tag[0]][tag[1]]++;
      }
      }
    }
  }

  function getTagOverviewString(tagOverview){
    let stringOut = "";
    for(let tag1 of Object.entries(tagOverview)){
      stringOut += "\n" + tag1[0];
      let tag2Array = Object.entries(tag1[1]);
      tag2Array.sort(function(a, b){
        if(a[1] === b[1]) return 0;
        else return (a[1] > b[1]) ? -1 : 1;
      })
      for(let tag2 of tag2Array){
        stringOut += "\n  " + tag2[0] + ": " + tag2[1];
      }
    }
  return stringOut;
  }
}


function newOsmMap(){
  let osmURL = prompt("Enter the openstreetmap URL of the map you want to generate and then select the fitting .osm.pbf file you can download here: https://download.geofabrik.de", "");
  if (osmURL === null) {
    console.log("no url given")
    return;
  }
  setZoom(1, true);
  setPan([0,0], true);
  currentOsmUrl = osmURL;
  triggerFileInput();
}

function triggerFileInput(){
  const fileInput = document.createElement("input");
  fileInput.type = "file";
  fileInput.accept = ".pbf"
  
  fileInput.addEventListener("change", function(){
    currentFileName = this.files[0].name;
    let reader = new FileReader();
    reader.onload = function() {
      drawRulesInputJson = JSON.parse(uiObj.textarea.value);
      updateMapObj(draw, this.result, currentOsmUrl);
    }
    reader.readAsArrayBuffer(this.files[0]);
  }, false);
  
  fileInput.click();
}


function mapSettingsChanged(){
  currentSlectionStart = uiObj.textarea.selectionStart;
  try{
    drawRulesInputJson = JSON.parse(uiObj.textarea.value);
    draw();
  }
  catch(error){
    alert(error)
  }
  uiObj.textarea.focus();
  uiObj.textarea.setSelectionRange(currentSlectionStart, currentSlectionStart);
}

function setZoom(zoom, changeInTextareaAndURL){
  zoom = Math.round(zoom*10000)/10000;
  drawRulesInputJson[0]["zoom"] = zoom;
  if(changeInTextareaAndURL){
    uiObj.textarea.value = uiObj.textarea.value.replace(new RegExp(/"zoom": [+-]?\d+(\.\d+)?/), "\"zoom\": " + zoom)
    gat.setURLQueryParam("settings", uiObj.textarea.value)
  }
}

function setPan(pan, changeInTextareaAndURL){
  // map to "canvas size" to get pan right no matter the actual client Size
  pan[0] = pan[0] / svgDiv.element.clientWidth * drawRulesInputJson[0]["canvas size"][0];
  pan[1] = pan[1] / svgDiv.element.clientHeight * drawRulesInputJson[0]["canvas size"][1];

  pan[0] = pan[0] / drawRulesInputJson[0]["zoom"];
  pan[1] = pan[1] / drawRulesInputJson[0]["zoom"];
  
  pan[0] = Math.round(pan[0]);
  pan[1] = Math.round(pan[1]);


  drawRulesInputJson[0]["pan"] = pan;
  if(changeInTextareaAndURL){
    uiObj.textarea.value = uiObj.textarea.value.replace(new RegExp(/"pan": \[[+-]?\d+(\.\d+)?\,[+-]?\d+(\.\d+)?\]/), "\"pan\": [" + pan[0]  + "," + pan[1] + "]")
    gat.setURLQueryParam("settings", uiObj.textarea.value);
  }
}

function draw(saveFlag){
  if(saveFlag !== true){
    gat.setURLQueryParam("settings", uiObj.textarea.value)
    
    let mainSVG = document.getElementById("mainSVG");
    if(mainSVG !== null) mainSVG.remove();
    svgDiv.element.style.backgroundColor = drawRulesInputJson[0]["background"];
    
  }
  
  let size = drawRulesInputJson[0]["canvas size"];
  svgDiv.size = size

  var ctx = SVG();
  ctx.viewbox(0, 0, ...size)

  ctx.node.id = "mainSVG";
  ctx.node.style="width:100%; height:100%"
  ctx.stroke({linecap: 'round', linejoin: 'round'})

  if(saveFlag === true){
    let rect = ctx.rect(9*size[0], 9*size[1]);
    rect.move(-4*size[0], -4*size[1])
    rect.fill(drawRulesInputJson[0]["background"])
    let scale = drawRulesInputJson[0]["zoom"];
    let panX = drawRulesInputJson[0]["pan"][0];
    let panY = drawRulesInputJson[0]["pan"][1]
    ctx.transform({
      a: scale, b: 0, c: 0, d: scale, e: panX*scale, f: panY*scale
    })
  }

  let drawingSettings = getDrawingSettings(drawRulesInputJson);

  for(tag of drawingSettings.drawingOrder){
    if(tag[2] === "way"){
      if(drawingSettings.orderedWays[tag[0]] === undefined || drawingSettings.orderedWays[tag[0]][tag[1]] === undefined) continue;
      drawWays(ctx, drawingSettings, tag);
    }
    else if(tag[2] === "node"){
      if(drawingSettings.orderedNodes[tag[0]] === undefined || drawingSettings.orderedNodes[tag[0]][tag[1]] === undefined) continue;
      drawNodes(ctx, drawingSettings, tag);
    }
  }

  if(saveFlag === true){
    return ctx.svg()
  }
  else {
    gat.setURLQueryParam("osm-url", currentOsmUrl);
    gat.setURLQueryParam("file-name", currentFileName);
    
    ctx.addTo(svgDiv.element);
    var panZoomSVG = svgPanZoom("#mainSVG", {
      controlIconsEnabled: true,
      onZoom: function(){
        setZoom(panZoomSVG.getZoom(), true);
        // pan is changing with each zoom
        let pan = panZoomSVG.getPan();
        setPan([pan.x, pan.y], true);
      },
      onPan: function(){
        let pan = panZoomSVG.getPan();
        setPan([pan.x, pan.y], true);
      },
    })

    // map to client size to get pan right no matter the actual client Size
    let panX = drawRulesInputJson[0]["pan"][0] / drawRulesInputJson[0]["canvas size"][0] * svgDiv.element.clientWidth;
    let panY = drawRulesInputJson[0]["pan"][1] / drawRulesInputJson[0]["canvas size"][1] * svgDiv.element.clientHeight;

    let zoom = drawRulesInputJson[0]["zoom"];
    panZoomSVG.zoom(zoom);



    panZoomSVG.pan({x:panX*zoom, y:panY*zoom});

    return;
  }

  function drawNodes(ctx, drawingSettings, tag){
    tagDrawSettings = drawingSettings.drawRulesNodes[tag[0]][tag[1]];
    for(xy of drawingSettings.orderedNodes[tag[0]][tag[1]]){
      let circle = ctx.circle(tagDrawSettings.size);
      circle.move(xy[0], xy[1]);
      circle.fill(tagDrawSettings.fillColor);
      if(tagDrawSettings.strokeColor !== undefined){
        circle.stroke({width: tagDrawSettings.lineWidth, color: tagDrawSettings.strokeColor})
      }
    }
  }

  function drawWays(ctx, drawingSettings, tag){
    tagDrawSettings = drawingSettings.drawRulesWays[tag[0]][tag[1]];
    for(nodeRefs of drawingSettings.orderedWays[tag[0]][tag[1]]){
      let beginPath = true;
      let polylinePoints = [];
      for(nodeId of nodeRefs){
        if(map.nodes[nodeId] == undefined){
          beginPath = true;
          continue;
        } else if(beginPath == true){
          drawPolyline(polylinePoints, tagDrawSettings)
          beginPath = false;
        }
        polylinePoints.push(map.nodes[nodeId].x);
        polylinePoints.push(map.nodes[nodeId].y);
      }
      drawPolyline(polylinePoints, tagDrawSettings)
    }
  }

  function drawPolyline(polylinePoints, tagDrawSettings){
    if(polylinePoints.length>0){
      let polyline = ctx.polyline(polylinePoints);
      polyline.fill(tagDrawSettings.fillColor);
      polyline.stroke({width: tagDrawSettings.lineWidth, color: tagDrawSettings.strokeColor})
      polylinePoints = []
    }
  }
}


async function updateMapObj(callback, mapArrayBuffer){
  let filePath;
  //console.log(currentFileName)
  if(localFileNames.indexOf(currentFileName) >- 1){
    //console.log("server available map")
    filePath = "maps/" + currentFileName;
  }

  loaderText = gat.addLoaderText();
  
  map = getEmptyMapWithBorders(currentOsmUrl);

  loaderText.innerText = "loading ...";

  await pbfParser.parse(getpbfParser(callback, filePath, mapArrayBuffer));

  function getEmptyMapWithBorders(osmURL){
    let zoomlevel, midLat, midLon;
    let valueBeginIndex = osmURL.search("#map") + 5;
    [zoomlevel, midLat, midLon] = osmURL.substr(valueBeginIndex).split("/").map(value => parseFloat(value));

    let widthLon = 360 / Math.pow(2, zoomlevel-1);
    let widthHeightRatio = svgDiv.element.height/svgDiv.element.width;
    let heightLat = widthLon*widthHeightRatio;

    let map = {
      nodes: {},
      ways: {},
      relations: {},
      counterNode: 0,
      counterWay: 0,
      

      mapPixelWidth: svgDiv.element.width,
      mapPixelHeight: svgDiv.element.height,
      mapLonDelta: widthLon,
      mapLonLeft: midLon - widthLon/2,
      mapLatBottomDegree: midLat,

      minLon: midLon - widthLon/2 - mapAreaWidthDegreeAddition,
      minLat: midLat - heightLat/2 - mapAreaWidthDegreeAddition,
      maxLon: midLon + widthLon/2 + mapAreaWidthDegreeAddition,
      maxLat: midLat + heightLat/2 + mapAreaWidthDegreeAddition,

      canvasWidth: svgDiv.element.width,
      canvasHeight: svgDiv.element.height,
    }

    let borderXY = [
      ...convertGeoToGlobalPixel(map, midLat - heightLat/2, midLon - widthLon/2),
      ...convertGeoToGlobalPixel(map, midLat + heightLat/2, midLon + widthLon/2)
    ];

    map.borderXY = borderXY;
    map.width = borderXY[2] - borderXY[0];
    map.height = borderXY[3] - borderXY[1];

    return map;
  }

  function getpbfParser(callback, filePath, mapArrayBuffer){
    return {
      filePath: filePath,
      buffer: mapArrayBuffer,
      interval: setInterval(function(){
        loaderText.innerText = "loaded: " + map.counterNode + " ways and " + map.counterWay + " nodes";
      }, 1000),
      startTime: Date.now(), 
      endDocument: function(){
        
        clearInterval(this.interval)
        let millis = Date.now() - this.startTime;
        console.log(millis/1000, "seconds to load the selected area");
        
        gat.removeLoaderText();
        callback();
      },
      node: function(node){
        if(node.lon<map.minLon || node.lat<map.minLat || node.lon>map.maxLon || node.lat>map.maxLat) return

        [x, y] = convertGeoToCanvasPixel(map, node.lat, node.lon);
        map.nodes[node.id] = {
          x: x,
          y: y,
          tags: Object.entries(node.tags),
        }
        map.counterNode++;
      },
      way: function(way){
        for(nodeKey of way.nodeRefs){
          if(map.nodes[nodeKey]){
            map.ways[way.id] = {
              nodeRefs: way.nodeRefs,
              tags: Object.entries(way.tags),
            }
            map.counterWay++;
            return;
          }
        }
      },
      relation: function(relation){},
      error: function(msg){
        console.error('error: ' + msg);
        throw msg;
      }
    }
  }

  function convertGeoToCanvasPixel(map, lat, lon){
    [x, y] = convertGeoToGlobalPixel(map, lat, lon);
    x = (x-map.borderXY[0])/map.width * map.canvasWidth;
    y = (y-map.borderXY[1])/map.height * map.canvasHeight;
    y = -(y - map.canvasHeight/2) + map.canvasHeight/2;
    return [x, y]
  }

  function convertGeoToGlobalPixel(map, lat, lon){
    let x = (lon - map.mapLonLeft) * (map.mapPixelWidth / map.mapLonDelta);
    lat = lat * Math.PI / 180;
    let worldMapWidth = ((map.mapPixelWidth / map.mapLonDelta) * 360) / (2 * Math.PI);
    let mapOffsetY = (worldMapWidth / 2 * Math.log((1 + Math.sin(map.mapLatBottomDegree)) / (1 - Math.sin(map.mapLatBottomDegree))));
    let y = map.mapPixelHeight - ((worldMapWidth / 2 * Math.log((1 + Math.sin(lat)) / (1 - Math.sin(lat)))) - mapOffsetY);
    return [x, y];
  }

  
}


function getDrawingSettings(drawRulesInputJson){
  let drawingSettings = getDrawingSettingsRulesAndOrder(drawRulesInputJson);

  drawingSettings.orderedWays = getOrderedWays(drawingSettings);
  drawingSettings.orderedNodes = getOrderedNodes(drawingSettings);
  return drawingSettings;

  function getDrawingSettingsRulesAndOrder(drawRulesInputJson){
    let drawingSettings = {};
    drawingSettings.drawRulesWays = {};
    drawingSettings.drawRulesNodes = {};
    drawingSettings.drawingOrder = [];

    for(let drawRule of drawRulesInputJson){
      drawSettings = {
        strokeColor: drawRule["stroke color"],
        lineWidth: drawRule["line width"],
        fillColor: drawRule["fill color"],
        size: drawRule["size"],
      }
      if(drawSettings.fillColor === undefined) drawSettings.fillColor = "none";
      if(drawRule.type === "way"){
        for(let tag of drawRule.tags){
          if(drawingSettings.drawRulesWays[tag[0]] === undefined){
            drawingSettings.drawRulesWays[tag[0]] = {};
          }
          drawingSettings.drawRulesWays[tag[0]][tag[1]] = drawSettings;
          drawingSettings.drawingOrder.push([tag[0], tag[1], "way"])
        } 
      } else if(drawRule.type === "node"){
        for(let tag of drawRule.tags){
          if(drawingSettings.drawRulesNodes[tag[0]] === undefined){
            drawingSettings.drawRulesNodes[tag[0]] = {};
          }
          drawingSettings.drawRulesNodes[tag[0]][tag[1]] = drawSettings;
          drawingSettings.drawingOrder.push([tag[0], tag[1], "node"])
        } 
      }
    }
    return drawingSettings;
  }

  function getOrderedWays(drawingSettings){
    let orderedWays = {}
    for(let way of Object.entries(map.ways)){
      for(let tag of way[1].tags){
        let rule = drawingSettings.drawRulesWays[tag[0]];
        if(rule !== undefined){
          if(rule["*"] !== undefined){
            if(orderedWays[tag[0]] === undefined){
              orderedWays[tag[0]] = {};
            }
            if(orderedWays[tag[0]]["*"] === undefined){
              orderedWays[tag[0]]["*"] = [];
            }
            orderedWays[tag[0]]["*"].push(way[1].nodeRefs);
          } else if(rule[tag[1]] !== undefined){
            if(orderedWays[tag[0]] === undefined){
              orderedWays[tag[0]] = {};
            }
            if(orderedWays[tag[0]][tag[1]] === undefined){
              orderedWays[tag[0]][tag[1]] = [];
            }
            orderedWays[tag[0]][tag[1]].push(way[1].nodeRefs);
          }
        }
      }
    }
    return orderedWays;
  }

  function getOrderedNodes(drawingSettings){
    let orderedNodes = {};
    for(let node of Object.entries(map.nodes)){
      for(let tag of node[1].tags){
        let rule = drawingSettings.drawRulesNodes[tag[0]];
        if(rule !== undefined){
          if(rule["*"] !== undefined){
            if(orderedNodes[tag[0]] === undefined){
              orderedNodes[tag[0]] = {};
            }
            if(orderedNodes[tag[0]]["*"] === undefined){
              orderedNodes[tag[0]]["*"] = [];
            }
            orderedNodes[tag[0]]["*"].push([node[1].x, node[1].y]);
          } else if(rule[tag[1]] !== undefined){
            if(orderedNodes[tag[0]] === undefined){
              orderedNodes[tag[0]] = {};
            }
            if(orderedNodes[tag[0]][tag[1]] === undefined){
              orderedNodes[tag[0]][tag[1]] = [];
            }
            orderedNodes[tag[0]][tag[1]].push([node[1].x, node[1].y]);
          }
        }
      }
    }
    return orderedNodes;
  }
}



</script>